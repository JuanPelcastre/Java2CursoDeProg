/////////////////////////////////////////////////////////////////
// Clase abstracta: árbol binario de búsqueda. Para utilizar los
// métodos proporcionados por esta clase, tendremos que crear
// una subclase de ella y redefinir los métodos:
// comparar y procesar.
//
public abstract class CArbolBinB<T>
{
  // Atributos del árbol binario
  private CNodo raíz = null; // raíz del árbol
  
  // Nodo de un árbol binario
  private class CNodo
  {
    // Atributos
    private T datos;           // referencia a los datos
    private CNodo izquierdo;   // raíz del subárbol izquierdo
    private CNodo derecho;     // raíz del subárbol derecho
    
    // Métodos
    public CNodo() {}          // constructor
  }
  
  // Posibles errores que se pueden dar relativos a un nodo
  public static final int CORRECTO  = 000;
  public static final int NO_DATOS  = 100;
  public static final int YA_EXISTE = 101;
  public static final int NO_EXISTE = 102;

  // Métodos del árbol binario
  public CArbolBinB() {}       // constructor
  
  // El método siguiente debe ser redefinido en una subclase para
  // que permita comparar dos nodos del árbol por el atributo
  // que necesitemos en cada momento.
  public abstract int comparar(T obj1, T obj2);
  
  // El método siguiente debe ser redefinido en una subclase para
  // que permita especificar las operaciones que se deseen
  // realizar con el nodo visitado.
  public abstract void procesar(T obj);

  public T buscar(T obj)
  {

    // Como ejercicio, complete el código según se explica en el libro

  }
  
  public int insertar(T obj)
  {
    // El método insertar permite añadir un nodo que aún no está
    // en el árbol.
    CNodo último = null, actual = raíz;
    int nComp = 0;

    if ( obj == null ) return NO_DATOS;
  
    // Comienza la búsqueda para verificar si ya hay un nodo con
    // estos datos en el árbol
    while (actual != null)
    {
      if ((nComp = comparar( obj, actual.datos )) == 0)
        break; // se encontró el nodo
      else
      {
        último = actual;
        if ( nComp < 0 )  // buscar en el subárbol izquierdo
          actual = actual.izquierdo;
        else              // buscar en el subárbol derecho
          actual = actual.derecho;
      }
    }

    if ( actual == null ) // no se encontró el nodo, añadirlo
    {
      CNodo nuevoNodo = new CNodo();
      nuevoNodo.datos = obj;
      nuevoNodo.izquierdo = nuevoNodo.derecho = null;

      // El nodo a añadir pasará a ser la raíz del árbol total si
      // éste está vacío, del subárbol izquierdo de "último" si la
      // comparación fue menor, o del subárbol derecho de "último" si
      // la comparación fue mayor.
      if ( último == null ) // árbol vacío
        raíz = nuevoNodo;
      else if ( nComp < 0 )
        último.izquierdo = nuevoNodo;
      else
        último.derecho = nuevoNodo;

      return CORRECTO;
    } // fin del bloque if ( actual == null )
    else // el nodo ya existe en el árbol
      return YA_EXISTE;
  }
  
  public T borrar(T obj)
  {
    // El método borrar permite eliminar un nodo del árbol.
    CNodo último = null, actual = raíz;
    CNodo marcado = null, sucesor = null;
    int nAnteriorComp = 0, nComp = -1;
    // nComp = -1 --> nodo más a la izquierda del subárbol derecho

    if (obj == null) return null; // NO_DATOS
  
    // Comienza la búsqueda para verificar si hay un nodo con
    // estos datos en el árbol.
    while ( actual != null )
    {
      nAnteriorComp = nComp; // resultado de la comparación anterior
      if (( nComp = comparar( obj, actual.datos )) == 0)
        break; // se encontró el nodo
      else
      {
        último = actual;
        if ( nComp < 0 )   // buscar en el subárbol izquierdo
          actual = actual.izquierdo;
        else               // buscar en el subárbol derecho
          actual = actual.derecho;
      }
    } // fin del bloque while ( actual != null )

    if ( actual != null ) // se encontró el nodo
    {
      marcado = actual;
      if (( actual.izquierdo == null && actual.derecho == null ))
        // se trata de un nodo terminal (no tiene descendientes)
        sucesor = null;
      else if ( actual.izquierdo == null ) // nodo sin subárbol izquierdo
        sucesor = actual.derecho;
      else if ( actual.derecho == null ) // nodo sin subárbol derecho
        sucesor = actual.izquierdo;
      else  // nodo con subárbol izquierdo y derecho
      {
        // Referencia al subárbol derecho del nodo a borrar
        sucesor = actual = actual.derecho;
        // Descender al nodo más a la izquierda en el subárbol
        // derecho de este nodo (el de valor más pequeño)
        while ( actual.izquierdo != null )
          actual = actual.izquierdo;
        // Sustituir el nodo a borrar por el nodo más a la izquierda
        // en el subárbol derecho que pasará a ser el nodo a borrar        
        marcado.datos = actual.datos;
        if (actual.derecho == null) marcado.derecho = null;
        // Identificar el nuevo nodo a borrar
        marcado = actual; // éste es ahora el nodo a borrar
        último = sucesor;
        sucesor = actual.derecho;
      }

      // Actualizar los enlaces prescindiendo de marcado
      if ( último != null )
      {
        if ( nAnteriorComp < 0 )
          último.izquierdo = sucesor;
        else
          último.derecho = sucesor;
      }
      else
        raíz = sucesor;
      
      return marcado.datos; // CORRECTO
      // "marcado" será enviado a la basura
    }
    else // el nodo buscado no está en el árbol
      return null; // NO_EXISTE
  }
  
  private void inorden( CNodo r , boolean nodoRaíz)
  {

    // Como ejercicio, complete el código según se explica en el libro

  }
  
  public void inorden()
  {
    // Si el segundo argumento es true, la visita comienza
    // en la raíz independientemente del primer argumento.
    inorden(null, true);
  }
}
/////////////////////////////////////////////////////////////////
